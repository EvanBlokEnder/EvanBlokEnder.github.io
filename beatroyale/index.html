e<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beat Royale</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        /*
        Key parts of the code:
        - Game states: Managed via 'currentState' variable (e.g., 'menu', 'battle', 'deckBuilder', etc.).
        - UI: Drawn on canvas using ctx.fillRect, ctx.fillText, etc. Buttons are rectangles checked for clicks.
        - Cards: Defined in 'allCards' array with stats. Player's deck is an array of 8 card indices.
        - Deck Builder: Select 8 unique cards from unlocked ones.
        - Shop: Buy unlocked cards with gold.
        - Settings: Toggle music, sound, difficulty.
        - Battles: Use canvas for arena. Towers and troops are objects with positions, HP, etc.
        - Elixir: Regenerates every second, max 10.
        - Rhythm: Beats every 500ms with visual pulse and beep. Deploy timing checked on mouseup: within 100ms for bonus (+20% stats), else penalty (-20%).
        - Bots: Easy - random deploys; Medium - basic counters; Hard - perfect timing, smart deploys.
        - Troops: Move towards enemy, attack in range. Simple collision detection for attacks.
        - Pathfinding: Basic - move straight to target, adjust if blocked (simple vector movement).
        - Audio: Uses AudioContext for simple beeps on beats and actions.
        - Responsiveness: Canvas resizes with window, elements scaled based on canvas size.
        - Input: Mouse and touch support (touchstart/mousedown, etc.).
        - Win/Loss: Based on towers destroyed or time (180s). Awards trophies, chests.
        - Chests: Simple random reward (gold or card unlock).
        - Clans: Mock text page.
        - Emotes: Buttons in battle to show text emotes.
        - Modes: Normal (no rhythm penalties) or Rhythm (full integration), toggled in settings.
        - Arenas: Background color changes with trophies.
        - Everything in one file, lightweight, no externals.
        */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scaleX = canvas.width / 800; // Base design on 800x600
            scaleY = canvas.height / 600;
            minScale = Math.min(scaleX, scaleY);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let scaleX, scaleY, minScale;

        // Audio Context for sounds
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playBeep(frequency = 440, duration = 0.1, volume = 0.5) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;
            oscillator.start();
            setTimeout(() => {
                oscillator.stop();
            }, duration * 1000);
        }

        // Game variables
        let currentState = 'menu';
        let trophies = 0;
        let gold = 100;
        let unlockedCards = [0,1,2,3,4]; // Initial unlocked
        let deck = [0,1,2,3,4,5,6,7]; // Default deck, but check unlocked in builder
        let hand = [];
        let nextCardIndex = 0;
        let playerElixir = 10;
        let botElixir = 10;
        let elixirTimer;
        let battleTimer = 180; // 3 minutes
        let battleInterval;
        let beatInterval;
        let lastBeatTime = 0;
        let beatTime = 500; // ms per beat
        let beatWindow = 100; // ms for perfect timing
        let pulseAlpha = 0;
        let settings = {
            music: true,
            sound: true,
            difficulty: 'medium', // easy, medium, hard
            mode: 'rhythm' // normal, rhythm
        };
        let arenaLevel = 1;
        let clan = 'No Clan';

        // All cards
        const allCards = [
            { name: 'Knight', cost: 3, hp: 1000, dmg: 100, speed: 2, attackSpeed: 1, range: 1, type: 'troop' },
            { name: 'Archer', cost: 3, hp: 500, dmg: 50, speed: 1, attackSpeed: 1.5, range: 5, type: 'troop' },
            { name: 'Giant', cost: 5, hp: 2000, dmg: 150, speed: 1, attackSpeed: 1.2, range: 1, type: 'troop', targetsBuildings: true },
            { name: 'Wizard', cost: 5, hp: 600, dmg: 200, attackSpeed: 1.5, range: 4, splash: true, type: 'troop' },
            { name: 'Fireball', cost: 4, dmg: 300, radius: 2, type: 'spell' },
            { name: 'Arrows', cost: 3, dmg: 100, radius: 4, type: 'spell' },
            { name: 'Goblin', cost: 2, hp: 300, dmg: 80, speed: 3, attackSpeed: 1, range: 1, type: 'troop' },
            { name: 'Skeleton', cost: 1, hp: 100, dmg: 50, speed: 2, attackSpeed: 1, range: 1, type: 'troop' },
            { name: 'Minion', cost: 3, hp: 400, dmg: 60, speed: 3, attackSpeed: 1, range: 2, type: 'troop', flying: true },
            { name: 'Balloon', cost: 5, hp: 1500, dmg: 500, speed: 1, attackSpeed: 3, range: 1, type: 'troop', flying: true, targetsBuildings: true }
        ];

        // Entities
        let troops = [];
        let spells = [];
        let playerTowers = {
            king: { x: 400, y: 550, hp: 3000, maxHp: 3000, dmg: 100, range: 7, attackSpeed: 1, lastAttack: 0 },
            princess1: { x: 200, y: 500, hp: 1500, maxHp: 1500, dmg: 80, range: 8, attackSpeed: 0.8, lastAttack: 0 },
            princess2: { x: 600, y: 500, hp: 1500, maxHp: 1500, dmg: 80, range: 8, attackSpeed: 0.8, lastAttack: 0 }
        };
        let botTowers = {
            king: { x: 400, y: 50, hp: 3000, maxHp: 3000, dmg: 100, range: 7, attackSpeed: 1, lastAttack: 0 },
            princess1: { x: 200, y: 100, hp: 1500, maxHp: 1500, dmg: 80, range: 8, attackSpeed: 0.8, lastAttack: 0 },
            princess2: { x: 600, y: 100, hp: 1500, maxHp: 1500, dmg: 80, range: 8, attackSpeed: 0.8, lastAttack: 0 }
        };

        // Input handling
        let mouse = { x: 0, y: 0, down: false, touch: false };
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX - canvas.getBoundingClientRect().left) / minScale;
            mouse.y = (e.clientY - canvas.getBoundingClientRect().top) / minScale;
        });
        canvas.addEventListener('mousedown', (e) => {
            mouse.down = true;
            handleClick(mouse.x, mouse.y);
        });
        canvas.addEventListener('mouseup', () => mouse.down = false);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.x = (touch.clientX - canvas.getBoundingClientRect().left) / minScale;
            mouse.y = (touch.clientY - canvas.getBoundingClientRect().top) / minScale;
            mouse.down = true;
            mouse.touch = true;
            handleClick(mouse.x, mouse.y);
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.x = (touch.clientX - canvas.getBoundingClientRect().left) / minScale;
            mouse.y = (touch.clientY - canvas.getBoundingClientRect().top) / minScale;
        });
        canvas.addEventListener('touchend', () => {
            mouse.down = false;
            mouse.touch = false;
        });

        let selectedCard = null;
        let dragStart = { x: 0, y: 0 };

        function handleClick(x, y) {
            // Scaled back to base 800x600
            x /= minScale;
            y /= minScale;
            if (currentState === 'menu') {
                // Check buttons
                if (x > 300 && x < 500 && y > 100 && y < 150) startBattle();
                if (x > 300 && x < 500 && y > 160 && y < 210) currentState = 'deckBuilder';
                if (x > 300 && x < 500 && y > 220 && y < 270) currentState = 'trophies';
                if (x > 300 && x < 500 && y > 280 && y < 330) currentState = 'shop';
                if (x > 300 && x < 500 && y > 340 && y < 390) currentState = 'settings';
                if (x > 300 && x < 500 && y > 400 && y < 450) currentState = 'clans';
                if (x > 300 && x < 500 && y > 460 && y < 510) window.close(); // Quit
            } else if (currentState === 'deckBuilder') {
                // Select cards
                for (let i = 0; i < unlockedCards.length; i++) {
                    const col = i % 5;
                    const row = Math.floor(i / 5);
                    if (x > 50 + col*150 && x < 150 + col*150 && y > 100 + row*100 && y < 180 + row*100) {
                        if (deck.includes(unlockedCards[i])) {
                            deck.splice(deck.indexOf(unlockedCards[i]), 1);
                        } else if (deck.length < 8) {
                            deck.push(unlockedCards[i]);
                        }
                    }
                }
                if (x > 300 && x < 500 && y > 500 && y < 550) currentState = 'menu'; // Back
            } else if (currentState === 'shop') {
                // Buy cards
                for (let i = 5; i < allCards.length; i++) { // Locked start from 5
                    const col = (i-5) % 5;
                    const row = Math.floor((i-5) / 5);
                    if (x > 50 + col*150 && x < 150 + col*150 && y > 100 + row*100 && y < 180 + row*100 && gold >= 50 && !unlockedCards.includes(i)) {
                        unlockedCards.push(i);
                        gold -= 50;
                    }
                }
                if (x > 300 && x < 500 && y > 500 && y < 550) currentState = 'menu'; // Back
            } else if (currentState === 'settings') {
                // Toggles
                if (x > 300 && x < 500 && y > 100 && y < 150) settings.music = !settings.music;
                if (x > 300 && x < 500 && y > 160 && y < 210) settings.sound = !settings.sound;
                if (x > 300 && x < 500 && y > 220 && y < 270) settings.difficulty = settings.difficulty === 'easy' ? 'medium' : settings.difficulty === 'medium' ? 'hard' : 'easy';
                if (x > 300 && x < 500 && y > 280 && y < 330) settings.mode = settings.mode === 'normal' ? 'rhythm' : 'normal';
                if (x > 300 && x < 500 && y > 500 && y < 550) currentState = 'menu'; // Back
            } else if (currentState === 'trophies' || currentState === 'clans' || currentState === 'win' || currentState === 'loss') {
                if (x > 300 && x < 500 && y > 500 && y < 550) currentState = 'menu'; // Back
            } else if (currentState === 'battle') {
                // Emotes
                if (x > 700 && x < 780 && y > 500 && y < 580) showEmote('ðŸ‘');
                if (x > 700 && x < 780 && y > 420 && y < 500) showEmote('ðŸ˜‚');

                // Select card
                for (let i = 0; i < hand.length; i++) {
                    if (x > 50 + i*150 && x < 150 + i*150 && y > 520 && y < 580 && playerElixir >= allCards[hand[i]].cost) {
                        selectedCard = hand[i];
                        dragStart.x = x;
                        dragStart.y = y;
                        if (settings.sound) playBeep(600, 0.05);
                    }
                }
            }
        }

        // For drag deploy in battle
        canvas.addEventListener('mouseup', (e) => {
            if (currentState === 'battle' && selectedCard !== null) {
                let deployX = mouse.x / minScale;
                let deployY = mouse.y / minScale;
                if (deployY > 300 && deployY < 600 && playerElixir >= allCards[selectedCard].cost) { // Own side
                    deployCard(selectedCard, deployX, deployY, 'player');
                }
                selectedCard = null;
            }
        });
        canvas.addEventListener('touchend', (e) => {
            if (currentState === 'battle' && selectedCard !== null) {
                let deployX = mouse.x;
                let deployY = mouse.y;
                if (deployY > 300 && deployY < 600 && playerElixir >= allCards[selectedCard].cost) {
                    deployCard(selectedCard, deployX, deployY, 'player');
                }
                selectedCard = null;
            }
        });

        let emoteText = '';
        let emoteTimer = 0;
        function showEmote(emote) {
            emoteText = emote;
            emoteTimer = 3000;
        }

        function deployCard(cardIndex, x, y, side) {
            const card = allCards[cardIndex];
            const now = Date.now();
            let timingBonus = 1;
            if (settings.mode === 'rhythm') {
                const timeDiff = Math.abs(now - lastBeatTime);
                if (timeDiff < beatWindow) {
                    timingBonus = 1.2; // +20%
                    if (settings.sound) playBeep(800, 0.1);
                } else {
                    timingBonus = 0.8; // -20%
                    if (settings.sound) playBeep(300, 0.1);
                }
            } else {
                if (settings.sound) playBeep(600, 0.05);
            }

            if (card.type === 'troop') {
                troops.push({
                    x, y,
                    hp: card.hp * timingBonus,
                    maxHp: card.hp * timingBonus,
                    dmg: card.dmg * timingBonus,
                    speed: card.speed,
                    range: card.range,
                    attackSpeed: card.attackSpeed,
                    lastAttack: 0,
                    side,
                    flying: card.flying || false,
                    targetsBuildings: card.targetsBuildings || false,
                    splash: card.splash || false,
                    target: null,
                    name: card.name
                });
            } else if (card.type === 'spell') {
                spells.push({
                    x, y,
                    dmg: card.dmg * timingBonus,
                    radius: card.radius,
                    side
                });
            }
            if (side === 'player') {
                playerElixir -= card.cost;
                // Cycle hand
                hand.splice(hand.indexOf(cardIndex), 1);
                hand.push(deck[nextCardIndex % deck.length]);
                nextCardIndex++;
            } else {
                botElixir -= card.cost;
            }
        }

        // Start battle
        function startBattle() {
            currentState = 'battle';
            troops = [];
            spells = [];
            playerElixir = 10;
            botElixir = 10;
            battleTimer = 180;
            playerTowers.king.hp = 3000;
            playerTowers.princess1.hp = 1500;
            playerTowers.princess2.hp = 1500;
            botTowers.king.hp = 3000;
            botTowers.princess1.hp = 1500;
            botTowers.princess2.hp = 1500;
            hand = deck.slice(0,4);
            nextCardIndex = 4;
            arenaLevel = Math.floor(trophies / 400) + 1;

            // Elixir regen
            elixirTimer = setInterval(() => {
                if (playerElixir < 10) playerElixir++;
                if (botElixir < 10) botElixir++;
            }, 1000);

            // Battle tick
            battleInterval = setInterval(updateBattle, 1000 / 60); // 60 fps sim

            // Beats
            if (settings.music) {
                beatInterval = setInterval(() => {
                    lastBeatTime = Date.now();
                    if (settings.sound) playBeep(440, 0.05, 0.3);
                    pulseAlpha = 1;
                }, beatTime);
            }

            // Bot AI
            botAIInterval = setInterval(botAI, getBotDeployInterval());
        }

        function getBotDeployInterval() {
            if (settings.difficulty === 'easy') return 5000;
            if (settings.difficulty === 'medium') return 3000;
            return 2000;
        }

        // Bot AI
        let botDeck = [0,1,2,3,4,5,6,7]; // Same as player for simplicity
        let botHand = botDeck.slice(0,4);
        let botNext = 4;
        function botAI() {
            // Choose card
            let cardIndex = botHand[Math.floor(Math.random() * botHand.length)];
            if (settings.difficulty === 'medium' || settings.difficulty === 'hard') {
                // Simple counter: if player has many troops, use spell
                const playerTroops = troops.filter(t => t.side === 'player').length;
                if (playerTroops > 3 && botHand.some(h => allCards[h].type === 'spell')) {
                    cardIndex = botHand.find(h => allCards[h].type === 'spell');
                }
            }
            const card = allCards[cardIndex];
            if (botElixir >= card.cost) {
                let deployX = Math.random() * 600 + 100;
                let deployY = Math.random() * 200 + 50; // Bot side
                if (settings.difficulty === 'hard') {
                    // Perfect timing
                    setTimeout(() => {
                        deployCard(cardIndex, deployX, deployY, 'bot');
                    }, beatTime - (Date.now() - lastBeatTime) % beatTime);
                } else {
                    deployCard(cardIndex, deployX, deployY, 'bot');
                }
                // Cycle
                botHand.splice(botHand.indexOf(cardIndex), 1);
                botHand.push(botDeck[botNext % botDeck.length]);
                botNext++;
            }
        }

        // Update battle logic
        function updateBattle() {
            const now = Date.now();
            // Update troops
            troops.forEach(t => {
                // Find target
                t.target = findTarget(t);
                if (t.target) {
                    // Attack if in range
                    if (distance(t, t.target) <= t.range * 20) { // Scale range
                        if (now - t.lastAttack > 1000 / t.attackSpeed) {
                            t.target.hp -= t.dmg;
                            if (t.splash) {
                                // Splash damage to nearby
                                getNearby(t.target, t.side === 'player' ? 'bot' : 'player', 2).forEach(n => n.hp -= t.dmg / 2);
                            }
                            t.lastAttack = now;
                            if (settings.sound) playBeep(500, 0.05, 0.2);
                        }
                    } else {
                        // Move towards target
                        moveTowards(t, t.target);
                    }
                } else {
                    // Move to enemy king
                    const enemyKing = t.side === 'player' ? botTowers.king : playerTowers.king;
                    moveTowards(t, enemyKing);
                }

                // Die
                if (t.hp <= 0) {
                    troops.splice(troops.indexOf(t), 1);
                }
            });

            // Towers attack
            [playerTowers, botTowers].forEach(towers => {
                Object.values(towers).forEach(tower => {
                    if (tower.hp > 0) {
                        const target = findTargetForTower(tower);
                        if (target && distance(tower, target) <= tower.range * 20) {
                            if (now - tower.lastAttack > 1000 / tower.attackSpeed) {
                                target.hp -= tower.dmg;
                                tower.lastAttack = now;
                                if (settings.sound) playBeep(400, 0.05, 0.2);
                            }
                        }
                    }
                });
            });

            // Spells
            spells.forEach(s => {
                // Apply damage to area
                const enemySide = s.side === 'player' ? 'bot' : 'player';
                getNearby(s, enemySide, s.radius).forEach(t => t.hp -= s.dmg);
                Object.values(s.side === 'player' ? botTowers : playerTowers).forEach(tower => {
                    if (distance(s, tower) < s.radius * 20) tower.hp -= s.dmg;
                });
                spells.splice(spells.indexOf(s), 1);
                if (settings.sound) playBeep(700, 0.1);
            });

            // Pulse decay
            pulseAlpha = Math.max(0, pulseAlpha - 0.02);

            // Timer
            battleTimer -= 1/60;
            if (battleTimer <= 0 || playerTowers.king.hp <= 0 || botTowers.king.hp <= 0) {
                endBattle();
            }

            // Emote timer
            if (emoteTimer > 0) emoteTimer -= 1000/60;

            draw(); // Draw every tick
        }

        function findTarget(t) {
            let enemies = troops.filter(e => e.side !== t.side && e.hp > 0);
            if (t.targetsBuildings) {
                // Prioritize buildings
                const enemyTowers = t.side === 'player' ? botTowers : playerTowers;
                const liveTowers = Object.values(enemyTowers).filter(tw => tw.hp > 0);
                if (liveTowers.length) return closest(t, liveTowers);
            }
            if (t.flying) enemies = enemies.filter(e => e.flying); // Air targets air
            return closest(t, enemies);
        }

        function findTargetForTower(tower) {
            const enemySide = tower === playerTowers.king || tower === playerTowers.princess1 || tower === playerTowers.princess2 ? 'bot' : 'player';
            let enemies = troops.filter(e => e.side === enemySide && e.hp > 0);
            return closest(tower, enemies);
        }

        function closest(entity, list) {
            if (!list.length) return null;
            return list.reduce((closest, current) => distance(entity, current) < distance(entity, closest) ? current : closest);
        }

        function getNearby(entity, side, radius) {
            return troops.filter(t => t.side === side && t.hp > 0 && distance(entity, t) < radius * 20);
        }

        function distance(a, b) {
            return Math.hypot(a.x - b.x, a.y - b.y);
        }

        function moveTowards(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 0) {
                from.x += (dx / dist) * from.speed;
                from.y += (dy / dist) * from.speed;
            }
        }

        function endBattle() {
            clearInterval(elixirTimer);
            clearInterval(battleInterval);
            clearInterval(beatInterval);
            clearInterval(botAIInterval);
            let playerCrowns = (botTowers.princess1.hp <= 0 ? 1 : 0) + (botTowers.princess2.hp <= 0 ? 1 : 0) + (botTowers.king.hp <= 0 ? 1 : 0);
            let botCrowns = (playerTowers.princess1.hp <= 0 ? 1 : 0) + (playerTowers.princess2.hp <= 0 ? 1 : 0) + (playerTowers.king.hp <= 0 ? 1 : 0);
            if (playerCrowns > botCrowns) {
                trophies += 30;
                currentState = 'win';
                // Chest reward
                gold += Math.floor(Math.random() * 50 + 50);
                if (unlockedCards.length < allCards.length && Math.random() > 0.5) {
                    let newCard = Math.floor(Math.random() * (allCards.length - unlockedCards.length)) + unlockedCards.length;
                    unlockedCards.push(newCard);
                }
            } else {
                trophies = Math.max(0, trophies - 20);
                currentState = 'loss';
            }
        }

        // Game loop
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            if (currentState !== 'battle') draw();
        }

        function draw() {
            ctx.save();
            ctx.scale(minScale, minScale);
            // Clear
            ctx.clearRect(0, 0, 800, 600);

            if (currentState === 'battle') {
                // Background arena
                ctx.fillStyle = arenaLevel === 1 ? '#87CEEB' : '#90EE90'; // Sky blue or green
                ctx.fillRect(0, 0, 800, 600);

                // Pulse
                ctx.fillStyle = `rgba(255,255,255,${pulseAlpha * 0.3})`;
                ctx.fillRect(0, 0, 800, 600);

                // Towers
                drawTower(playerTowers.king, 'King');
                drawTower(playerTowers.princess1, 'Princess');
                drawTower(playerTowers.princess2, 'Princess');
                drawTower(botTowers.king, 'King');
                drawTower(botTowers.princess1, 'Princess');
                drawTower(botTowers.princess2, 'Princess');

                // Troops
                troops.forEach(t => {
                    ctx.fillStyle = t.side === 'player' ? 'blue' : 'red';
                    ctx.fillRect(t.x - 10, t.y - 10, 20, 20);
                    // HP bar
                    ctx.fillStyle = 'green';
                    ctx.fillRect(t.x - 10, t.y - 15, 20 * (t.hp / t.maxHp), 3);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText(t.name[0], t.x - 5, t.y + 5);
                });

                // Hand
                hand.forEach((c, i) => {
                    ctx.fillStyle = playerElixir >= allCards[c].cost ? 'green' : 'gray';
                    ctx.fillRect(50 + i*150, 520, 100, 60);
                    ctx.fillStyle = 'black';
                    ctx.font = '14px Arial';
                    ctx.fillText(allCards[c].name, 55 + i*150, 540);
                    ctx.fillText(`Cost: ${allCards[c].cost}`, 55 + i*150, 560);
                });

                // Elixir
                ctx.fillStyle = 'purple';
                ctx.fillRect(10, 10, 20 * playerElixir, 20);
                ctx.fillStyle = 'black';
                ctx.fillText(`Elixir: ${playerElixir}`, 10, 50);

                // Timer
                ctx.fillText(`Time: ${Math.floor(battleTimer / 60)}:${Math.floor(battleTimer % 60).toString().padStart(2,'0')}`, 350, 20);

                // Emotes
                ctx.fillStyle = 'yellow';
                ctx.fillRect(700, 500, 80, 80);
                ctx.fillRect(700, 420, 80, 80);
                ctx.fillStyle = 'black';
                ctx.fillText('ðŸ‘', 730, 540);
                ctx.fillText('ðŸ˜‚', 730, 460);
                if (emoteTimer > 0) {
                    ctx.fillStyle = 'white';
                    ctx.fillText(emoteText, 400, 300);
                }

                // Drag preview
                if (selectedCard !== null) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = 'green';
                    ctx.fillRect(mouse.x / minScale - 10, mouse.y / minScale - 10, 20, 20);
                    ctx.globalAlpha = 1;
                }
            } else if (currentState === 'menu') {
                ctx.fillStyle = 'black';
                ctx.font = '30px Arial';
                ctx.fillText('Beat Royale', 300, 50);
                drawButton(300, 100, 200, 50, 'Play');
                drawButton(300, 160, 200, 50, 'Deck Builder');
                drawButton(300, 220, 200, 50, 'Trophies');
                drawButton(300, 280, 200, 50, 'Shop');
                drawButton(300, 340, 200, 50, 'Settings');
                drawButton(300, 400, 200, 50, 'Clans');
                drawButton(300, 460, 200, 50, 'Quit');
            } else if (currentState === 'deckBuilder') {
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                ctx.fillText('Deck Builder (Select 8 cards)', 200, 50);
                unlockedCards.forEach((c, i) => {
                    const col = i % 5;
                    const row = Math.floor(i / 5);
                    ctx.fillStyle = deck.includes(c) ? 'green' : 'gray';
                    ctx.fillRect(50 + col*150, 100 + row*100, 100, 80);
                    ctx.fillStyle = 'black';
                    ctx.fillText(allCards[c].name, 55 + col*150, 130 + row*100);
                });
                drawButton(300, 500, 200, 50, 'Back');
            } else if (currentState === 'shop') {
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                ctx.fillText(`Shop (Gold: ${gold})`, 200, 50);
                for (let i = 5; i < allCards.length; i++) {
                    if (!unlockedCards.includes(i)) {
                        const col = (i-5) % 5;
                        const row = Math.floor((i-5) / 5);
                        ctx.fillStyle = gold >= 50 ? 'yellow' : 'gray';
                        ctx.fillRect(50 + col*150, 100 + row*100, 100, 80);
                        ctx.fillStyle = 'black';
                        ctx.fillText(allCards[i].name, 55 + col*150, 130 + row*100);
                        ctx.fillText('50 Gold', 55 + col*150, 150 + row*100);
                    }
                }
                drawButton(300, 500, 200, 50, 'Back');
            } else if (currentState === 'settings') {
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                ctx.fillText('Settings', 300, 50);
                drawButton(300, 100, 200, 50, `Music: ${settings.music ? 'On' : 'Off'}`);
                drawButton(300, 160, 200, 50, `Sound: ${settings.sound ? 'On' : 'Off'}`);
                drawButton(300, 220, 200, 50, `Difficulty: ${settings.difficulty}`);
                drawButton(300, 280, 200, 50, `Mode: ${settings.mode}`);
                drawButton(300, 500, 200, 50, 'Back');
            } else if (currentState === 'trophies') {
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                ctx.fillText(`Trophies: ${trophies}`, 300, 200);
                ctx.fillText(`Rank: ${trophies < 400 ? 'Bronze' : 'Silver'}`, 300, 250);
                drawButton(300, 500, 200, 50, 'Back');
            } else if (currentState === 'clans') {
                ctx.fillStyle = 'black';
                ctx.font = '20px Arial';
                ctx.fillText(`Clan: ${clan}`, 300, 200);
                drawButton(300, 500, 200, 50, 'Back');
            } else if (currentState === 'win') {
                ctx.fillStyle = 'green';
                ctx.font = '30px Arial';
                ctx.fillText('Victory!', 350, 200);
                ctx.fillText(`Trophies: +30`, 350, 250);
                ctx.fillText(`Gold: +${Math.floor(Math.random() * 50 + 50)}`, 350, 300);
                drawButton(300, 500, 200, 50, 'Back');
            } else if (currentState === 'loss') {
                ctx.fillStyle = 'red';
                ctx.font = '30px Arial';
                ctx.fillText('Defeat', 350, 200);
                ctx.fillText(`Trophies: -20`, 350, 250);
                drawButton(300, 500, 200, 50, 'Back');
            }
            ctx.restore();
        }

        function drawButton(x, y, w, h, text) {
            ctx.fillStyle = 'blue';
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(text, x + 50, y + 30);
        }

        function drawTower(tower, type) {
            if (tower.hp <= 0) return;
            ctx.fillStyle = tower.y > 300 ? 'blue' : 'red'; // Player blue, bot red
            ctx.fillRect(tower.x - 20, tower.y - 20, 40, 40);
            ctx.fillStyle = 'green';
            ctx.fillRect(tower.x - 20, tower.y - 25, 40 * (tower.hp / tower.maxHp), 5);
            ctx.fillStyle = 'white';
            ctx.fillText(type[0], tower.x - 5, tower.y + 5);
        }

        gameLoop();
    </script>
</body>
</html>